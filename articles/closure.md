---
title: 深入理解Javascript中的闭包
date: 2020-06-24 16:11

categories:
- 大前端
tags:
- JavaScript

---

**文本主要介绍闭包的原理以及常见用途。**

<br>

@[toc]

<br>

## 前言

在正式介绍闭包之前，先介绍两个概念，这两个概念在学习闭包原理的时候非常有用：

1. 函数在创建的时候除了函数对象本身会被创建以外还会创建一个**作用域链对象**，它是一个栈结构的对象，自底向上依次存储当前函数作用域链上函数的的**活动对象**。
2. 函数在调用的时候才会创建**活动对象**，活动对象里包含了当前函数执行时自己局部的变量和函数，而这个活动对象就会在这时进入当前函数作用域链对象的栈结构里。

接着咱们来聊聊关于变量作用域的问题（此处不考虑let和const块级作用域）：

1. 全局变量：全局变量存在于整个程序的运行过程中，随处都可以访问，也就意味着随处都可以修改。
2. 局部变量：只有在当前函数内部才可以访问的变量，别的地方不能访问也不能修改。

我们可以看出，全局变量是可以在声明之后重复使用的，但是也就意味着如果在某一处对他做了修改，那么别处也将应用这个修改，我们称之为**“全局污染”**。局部变量是不存在这个问题的，但是又不能重复使用，那么如果我们希望能有一种变量既可以重复使用又不会污染全局的话，就可以使用**闭包**。



## 什么是闭包？

以下是[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures) 对于闭包的解释：

> 函数和对其周围状态（**lexical environment，词法环境**）的引用捆绑在一起构成**闭包**（**closure**）。也就是说，闭包可以让你从内部函数访问外部函数作用域。在 JavaScript 中，每当函数被创建，就会在函数生成时生成闭包。

**简单地说：闭包就是由嵌套函数形成的一个词法环境。**

有了闭包，我们就可以在一个函数里访问另外一个函数的局部变量，这个变量可以重复使用且不会造成全局污染。

```javascript
function numCompany () {
  var n = 1
  function getNum () {
    return ++n
  }
  return getNum
}
```

以上代码就是一个经典的闭包，一般构成闭包有三步：

1. 外层函数嵌套内层函数
2. 内层函数使用外层函数的局部变量（或参数）
3. 将内层函数作为外层函数的返回值

然后我们就可以调用以上函数

```javascript
var fn = numCompany()
console.log(fn()) // 2
console.log(fn()) // 3
console.log(fn()) // 4
```

这里的`fn`接收的就是`numCompany`的返回值也就是内层函数，所以`fn`可以直接调用。而且反复调用`fn`会把`numCompany`的局部变量`n`持续`++`。也就是说，我们在`fn`这个函数里反复操作了`numCompany`的局部变量`n`，这就是闭包。

由此可见，闭包可以：

1. 在一个函数里访问另一个函数的局部变量，也就是访问另外一个作用域
2. 变量即可以重复使用又不会污染全局（因为别的地方访问不到）

以上的例子我们可以用一个形象的比喻：外层`numCompany`函数是银行大厅的一个取号机，机器里的`getNum`是取号的算法，那么调用一次`numCompany`就相当于安装了一台机器，然后就得到了取号的算法，以后有人来办理业务需要取号就只需要调用这个算法，得到的号码就是依次加一的。那么我们继续看下面的代码

```javascript
var fn = numCompany()
console.log(fn()) // 2
console.log(fn()) // 3
console.log(fn()) // 4
var fn1 = numCompany()
console.log(fn1()) // 2
console.log(fn1()) // 3
console.log(fn1()) // 4
```

如果我们调用两次外层函数，分别调用`fn`和`fn1`他们得到的结果是操作的同一个`n`吗？结果明显不是，好比建设银行和招商银行分别安装了取号机，他们取到的号码会互相影响吗？明显不会。

**每调用一次外层函数就得到一套闭包，多次调用时多个闭包，不会互相影响。**



## 闭包的原理

为什么闭包可以实现这样的功能？接下来我们以上面的代码为例来看看闭包的形成过程。

```javascript
function numCompany () {
  var n = 1
  function getNum () {
    return ++n
  }
  return getNum
}
var fn = numCompany()
console.log(fn()) // 2

```

### 一、预解析

预解析的时候变量提升，`fn`还是`undefined`，外层函数被声明，我们假设函数地址是`0x1001`，这个时候除了函数本身被创建，还有他的**作用域链对象**也同时被创建了，不过



















